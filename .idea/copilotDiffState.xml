<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/kotlin/config/ConfigSynchronizer.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/config/ConfigSynchronizer.kt" />
              <option name="originalContent" value="/*&#10; * Copyright (C) 2025 Oliver Froberg (The Panda Oliver)&#10; *&#10; * This program is free software: you can redistribute it and/or modify&#10; *  it under the terms of the GNU Lesser General Public License as published by&#10; *  the Free Software Foundation, either version 3 of the License, or&#10; *  any later version.&#10; *&#10; * You should have received a copy of the GNU Lesser General Public License&#10; *  along with this program. If not, see &lt;https://www.gnu.org/licenses/&gt;.&#10; */&#10;&#10;package dev.pandasystems.pandalib.config&#10;&#10;import dev.pandasystems.pandalib.PandaLib&#10;import dev.pandasystems.pandalib.config.ConfigSynchronizer.configs&#10;import dev.pandasystems.pandalib.event.server.serverConfigurationConnectionEvent&#10;import dev.pandasystems.pandalib.networking.PayloadCodecRegistry&#10;import dev.pandasystems.pandalib.networking.ServerConfigurationNetworking&#10;import dev.pandasystems.pandalib.networking.ServerPlayNetworking&#10;import dev.pandasystems.pandalib.networking.payloads.config.ClientboundConfigRequestPayload&#10;import dev.pandasystems.pandalib.networking.payloads.config.CommonConfigPayload&#10;import dev.pandasystems.universalserializer.elements.TreeObject&#10;import net.minecraft.resources.ResourceLocation&#10;import net.minecraft.world.entity.player.Player&#10;import java.util.*&#10;import kotlin.jvm.optionals.getOrNull&#10;import kotlin.reflect.KProperty&#10;import kotlin.reflect.KProperty0&#10;import kotlin.reflect.KType&#10;&#10;object ConfigSynchronizer {&#10;&#9;// ConfigObjects resourceLocation -&gt; List of SyncableConfigOptions&#10;&#9;internal val configs = mutableMapOf&lt;ResourceLocation, MutableList&lt;SyncableOption&lt;Any?&gt;&gt;&gt;()&#10;&#10;&#9;internal fun init() {&#10;&#9;&#9;PandaLib.logger.debug(&quot;Config Synchronizer is initializing...&quot;)&#10;&#9;&#9;PayloadCodecRegistry.register(CommonConfigPayload.TYPE, CommonConfigPayload.CODEC)&#10;&#9;&#9;PayloadCodecRegistry.register(ClientboundConfigRequestPayload.TYPE, ClientboundConfigRequestPayload.CODEC)&#10;&#10;&#10;&#9;&#9;// Config receiving&#10;&#9;&#9;ServerConfigurationNetworking.registerHandler(CommonConfigPayload.TYPE) { payload, _ -&gt;&#10;&#9;&#9;&#9;val resourceLocation = payload.resourceLocation&#10;&#9;&#9;&#9;val jsonObject = payload.optionObject&#10;&#9;&#9;&#9;val playerId = payload.playerId&#10;&#9;&#9;&#9;PandaLib.logger.debug(&quot;Received config payload for {}: {}&quot;, resourceLocation, jsonObject)&#10;&#9;&#9;&#9;val configObject = ConfigRegistry.get&lt;Any&gt;(resourceLocation)&#10;&#9;&#9;&#9;configObject?.applyConfigPayload(jsonObject, playerId.getOrNull())&#10;&#9;&#9;&#9;&#9;?: PandaLib.logger.error(&quot;Received config payload for unknown config object: $resourceLocation&quot;)&#10;&#10;&#9;&#9;&#9;// Provide the new player config to all already connected clients&#10;&#9;&#9;&#9;playerId.ifPresent {&#10;&#9;&#9;&#9;&#9;PandaLib.logger.debug(&quot;Sending config payload to player {}&quot;, it)&#10;&#9;&#9;&#9;&#9;ServerPlayNetworking.sendToAll(payload)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#10;&#9;&#9;// Config sending&#10;&#10;&#9;&#9;if (configs.isNotEmpty()) {&#10;&#9;&#9;&#9;serverConfigurationConnectionEvent.register { handler, _ -&gt;&#10;&#9;&#9;&#9;&#9;// Send all server configs&#10;&#9;&#9;&#9;&#9;PandaLib.logger.debug(&quot;Sending all server configs to {}&quot;, handler.owner.name)&#10;&#9;&#9;&#9;&#9;val payloads = configs.map { (resourceLocation, _) -&gt;&#10;&#9;&#9;&#9;&#9;&#9;val configObject = requireNotNull(ConfigRegistry.get&lt;Any&gt;(resourceLocation))&#10;&#9;&#9;&#9;&#9;&#9;configObject.createConfigPayload()&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;ServerConfigurationNetworking.send(handler, payloads)&#10;&#10;&#9;&#9;&#9;&#9;// Send all previous client configs to the new client&#10;&#9;&#9;&#9;&#9;PandaLib.logger.debug(&quot;Sending previous client configs to {}&quot;, handler.owner.name)&#10;&#9;&#9;&#9;&#9;createConfigPayloadsWithClientConfigs()&#10;&#9;&#9;&#9;&#9;&#9;.takeIf { it.isNotEmpty() }&#10;&#9;&#9;&#9;&#9;&#9;?.let { ServerConfigurationNetworking.send(handler, it) }&#10;&#10;&#9;&#9;&#9;&#9;// Send request for all client's configs&#10;&#9;&#9;&#9;&#9;PandaLib.logger.debug(&quot;Sending config request to {}&quot;, handler.owner.name)&#10;&#9;&#9;&#9;&#9;ServerConfigurationNetworking.send(handler, ClientboundConfigRequestPayload(handler.owner.id))&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;PandaLib.logger.debug(&quot;Config Synchronizer initialized successfully.&quot;)&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Creates a CommonConfigPayload for the given player UUID.&#10;&#9; *&#10;&#9; * If the player UUID is null, the payload will be created for the server.&#10;&#9; */&#10;&#9;fun ConfigObject&lt;*&gt;.createConfigPayload(playerUuid: UUID? = null): CommonConfigPayload {&#10;&#9;&#9;return CommonConfigPayload(resourceLocation, createJsonObject(resourceLocation), Optional.ofNullable(playerUuid))&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Creates a list of CommonConfigPayloads for all client configs.&#10;&#9; *&#10;&#9; * Should be called on the server when a new client connects to provide the client with all connected client configs.&#10;&#9; */&#10;&#9;fun createConfigPayloadsWithClientConfigs(): Collection&lt;CommonConfigPayload&gt; {&#10;&#9;&#9;val payloadValues = mutableMapOf&lt;UUID, Pair&lt;ResourceLocation, TreeObject&gt;&gt;()&#10;&#9;&#9;configs.forEach { (resourceLocation, options) -&gt;&#10;&#9;&#9;&#9;options.forEach { option -&gt;&#10;&#9;&#9;&#9;&#9;val configObject = option.configObject&#10;&#9;&#9;&#9;&#9;option.playerValues.forEach { (playerUuid, value) -&gt;&#10;&#9;&#9;&#9;&#9;&#9;payloadValues.computeIfAbsent(playerUuid) { resourceLocation to TreeObject() }&#10;&#9;&#9;&#9;&#9;&#9;&#9;.second[option.id] = configObject.serializer.toTree(value, option.valueType)&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;return payloadValues.map { (uuid, pair) -&gt; CommonConfigPayload(pair.first, pair.second, Optional.of(uuid)) }&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Applies the given values to the given config object.&#10;&#9; */&#10;&#9;fun ConfigObject&lt;*&gt;.applyConfigPayload(tree: TreeObject, playerUuid: UUID?) {&#10;&#9;&#9;println(tree)&#10;&#9;&#9;val options = requireNotNull(configs[resourceLocation]) { &quot;Config $resourceLocation is not registered&quot; }&#10;&#9;&#9;for (option in options) {&#10;&#9;&#9;&#9;val deserialized = serializer.fromTree(tree[option.id]!!, option.valueType)&#10;&#9;&#9;&#9;requireNotNull(deserialized) { &quot;Failed to deserialize value for option ${option.property.name}&quot; }&#10;&#9;&#9;&#9;if (playerUuid != null) // Set synced value for the player&#10;&#9;&#9;&#9;&#9;option.playerValues[playerUuid] = deserialized&#10;&#9;&#9;&#9;else // Set synced value for the server&#10;&#9;&#9;&#9;&#9;option.serverValue = deserialized&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;fun createJsonObject(resourceLocation: ResourceLocation): TreeObject {&#10;&#9;&#9;val options = requireNotNull(configs[resourceLocation]) { &quot;Config $resourceLocation is not registered&quot; }&#10;&#9;&#9;val tree = TreeObject()&#10;&#9;&#9;for (option in options) {&#10;&#9;&#9;&#9;val configObject = option.configObject&#10;&#9;&#9;&#9;tree[option.id] = configObject.serializer.toTree(option.initialValue, option.valueType)&#10;&#9;&#9;}&#10;&#9;&#9;return tree&#10;&#9;}&#10;&#10;&#9;class SyncableOption&lt;T : Any?&gt;(val configObject: ConfigObject&lt;*&gt;, val property: KProperty0&lt;T&gt;) {&#10;&#9;&#9;val id: String = &quot;${configObject.resourceLocation}#${property.javaClass.declaringClass?.name ?: property::class.qualifiedName}.${property.name}&quot;&#10;&#9;&#9;val valueType: KType = property.returnType&#10;&#9;&#9;val initialValue: T get() = property.get()&#10;&#10;&#9;&#9;internal val playerValues = mutableMapOf&lt;UUID, T&gt;()&#10;&#9;&#9;var serverValue: T? = null&#10;&#9;&#9;&#9;get() = field ?: initialValue&#10;&#10;&#9;&#9;operator fun get(player: UUID): T {&#10;&#9;&#9;&#9;val playerValue = playerValues[player]&#10;&#9;&#9;&#9;if (playerValue != null) return playerValue&#10;&#9;&#9;&#9;PandaLib.logger.warn(&quot;No synced value for player $player in config option ${property.name}&quot;)&#10;&#9;&#9;&#9;return initialValue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;operator fun get(player: Player): T = this[player.uuid]&#10;&#9;}&#10;}&#10;&#10;fun ConfigObject&lt;*&gt;.syncOption(property: KProperty0&lt;*&gt;) {&#10;&#9;configs.computeIfAbsent(this.resourceLocation) { mutableListOf() } +=&#10;&#9;&#9;ConfigSynchronizer.SyncableOption(this, property)&#10;}&#10;&#10;@Suppress(&quot;UNCHECKED_CAST&quot;)&#10;fun &lt;T : Any?&gt; ConfigObject&lt;*&gt;.getSynced(property: KProperty&lt;T&gt;): ConfigSynchronizer.SyncableOption&lt;T&gt; {&#10;&#9;return requireNotNull(configs[this.resourceLocation]?.find { it.property == property }) {&#10;&#9;&#9;&quot;Synced property $property is not registered for config ${this.resourceLocation}&quot;&#10;&#9;} as ConfigSynchronizer.SyncableOption&lt;T&gt;&#10;}" />
              <option name="updatedContent" value="/*&#10; * Copyright (C) 2025 Oliver Froberg (The Panda Oliver)&#10; *&#10; * This program is free software: you can redistribute it and/or modify&#10; *  it under the terms of the GNU Lesser General Public License as published by&#10; *  the Free Software Foundation, either version 3 of the License, or&#10; *  any later version.&#10; *&#10; * You should have received a copy of the GNU Lesser General Public License&#10; *  along with this program. If not, see &lt;https://www.gnu.org/licenses/&gt;.&#10; */&#10;&#10;package dev.pandasystems.pandalib.config&#10;&#10;import dev.pandasystems.pandalib.PandaLib&#10;import dev.pandasystems.pandalib.config.ConfigSynchronizer.configs&#10;import dev.pandasystems.pandalib.event.server.serverConfigurationConnectionEvent&#10;import dev.pandasystems.pandalib.networking.PayloadCodecRegistry&#10;import dev.pandasystems.pandalib.networking.ServerConfigurationNetworking&#10;import dev.pandasystems.pandalib.networking.ServerPlayNetworking&#10;import dev.pandasystems.pandalib.networking.payloads.config.ClientboundConfigRequestPayload&#10;import dev.pandasystems.pandalib.networking.payloads.config.CommonConfigPayload&#10;import dev.pandasystems.universalserializer.elements.TreeObject&#10;import net.minecraft.resources.ResourceLocation&#10;import net.minecraft.world.entity.player.Player&#10;import java.util.*&#10;import kotlin.jvm.optionals.getOrNull&#10;import kotlin.reflect.KProperty&#10;import kotlin.reflect.KProperty0&#10;import kotlin.reflect.KType&#10;&#10;object ConfigSynchronizer {&#10;&#9;// ConfigObjects resourceLocation -&gt; List of SyncableConfigOptions&#10;&#9;internal val configs = mutableMapOf&lt;ResourceLocation, MutableList&lt;SyncableOption&lt;Any?&gt;&gt;&gt;()&#10;&#10;&#9;internal fun init() {&#10;&#9;&#9;PandaLib.logger.debug(&quot;Config Synchronizer is initializing...&quot;)&#10;&#9;&#9;PayloadCodecRegistry.register(CommonConfigPayload.TYPE, CommonConfigPayload.CODEC)&#10;&#9;&#9;PayloadCodecRegistry.register(ClientboundConfigRequestPayload.TYPE, ClientboundConfigRequestPayload.CODEC)&#10;&#10;&#10;&#9;&#9;// Config receiving&#10;&#9;&#9;ServerConfigurationNetworking.registerHandler(CommonConfigPayload.TYPE) { payload, _ -&gt;&#10;&#9;&#9;&#9;val resourceLocation = payload.resourceLocation&#10;&#9;&#9;&#9;val jsonObject = payload.optionObject&#10;&#9;&#9;&#9;val playerId = payload.playerId&#10;&#9;&#9;&#9;PandaLib.logger.debug(&quot;Received config payload for {}: {}&quot;, resourceLocation, jsonObject)&#10;&#9;&#9;&#9;val configObject = ConfigRegistry.get&lt;Any&gt;(resourceLocation)&#10;&#9;&#9;&#9;configObject?.applyConfigPayload(jsonObject, playerId.getOrNull())&#10;&#9;&#9;&#9;&#9;?: PandaLib.logger.error(&quot;Received config payload for unknown config object: $resourceLocation&quot;)&#10;&#10;&#9;&#9;&#9;// Provide the new player config to all already connected clients&#10;&#9;&#9;&#9;playerId.ifPresent {&#10;&#9;&#9;&#9;&#9;PandaLib.logger.debug(&quot;Sending config payload to player {}&quot;, it)&#10;&#9;&#9;&#9;&#9;ServerPlayNetworking.sendToAll(payload)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#10;&#9;&#9;// Config sending&#10;&#10;&#9;&#9;if (configs.isNotEmpty()) {&#10;&#9;&#9;&#9;serverConfigurationConnectionEvent.register { handler, _ -&gt;&#10;&#9;&#9;&#9;&#9;// Send all server configs&#10;&#9;&#9;&#9;&#9;PandaLib.logger.debug(&quot;Sending all server configs to {}&quot;, handler.owner.name)&#10;&#9;&#9;&#9;&#9;val payloads = configs.map { (resourceLocation, _) -&gt;&#10;&#9;&#9;&#9;&#9;&#9;val configObject = requireNotNull(ConfigRegistry.get&lt;Any&gt;(resourceLocation))&#10;&#9;&#9;&#9;&#9;&#9;configObject.createConfigPayload()&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;ServerConfigurationNetworking.send(handler, payloads)&#10;&#10;&#9;&#9;&#9;&#9;// Send all previous client configs to the new client&#10;&#9;&#9;&#9;&#9;PandaLib.logger.debug(&quot;Sending previous client configs to {}&quot;, handler.owner.name)&#10;&#9;&#9;&#9;&#9;createConfigPayloadsWithClientConfigs()&#10;&#9;&#9;&#9;&#9;&#9;.takeIf { it.isNotEmpty() }&#10;&#9;&#9;&#9;&#9;&#9;?.let { ServerConfigurationNetworking.send(handler, it) }&#10;&#10;&#9;&#9;&#9;&#9;// Send request for all client's configs&#10;&#9;&#9;&#9;&#9;PandaLib.logger.debug(&quot;Sending config request to {}&quot;, handler.owner.name)&#10;&#9;&#9;&#9;&#9;ServerConfigurationNetworking.send(handler, ClientboundConfigRequestPayload(handler.owner.id))&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;PandaLib.logger.debug(&quot;Config Synchronizer initialized successfully.&quot;)&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Creates a CommonConfigPayload for the given player UUID.&#10;&#9; *&#10;&#9; * If the player UUID is null, the payload will be created for the server.&#10;&#9; */&#10;&#9;fun ConfigObject&lt;*&gt;.createConfigPayload(playerUuid: UUID? = null): CommonConfigPayload {&#10;&#9;&#9;return CommonConfigPayload(resourceLocation, createJsonObject(resourceLocation), Optional.ofNullable(playerUuid))&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Creates a list of CommonConfigPayloads for all client configs.&#10;&#9; *&#10;&#9; * Should be called on the server when a new client connects to provide the client with all connected client configs.&#10;&#9; */&#10;&#9;fun createConfigPayloadsWithClientConfigs(): Collection&lt;CommonConfigPayload&gt; {&#10;&#9;&#9;val payloadValues = mutableMapOf&lt;UUID, Pair&lt;ResourceLocation, TreeObject&gt;&gt;()&#10;&#9;&#9;configs.forEach { (resourceLocation, options) -&gt;&#10;&#9;&#9;&#9;options.forEach { option -&gt;&#10;&#9;&#9;&#9;&#9;val configObject = option.configObject&#10;&#9;&#9;&#9;&#9;option.playerValues.forEach { (playerUuid, value) -&gt;&#10;&#9;&#9;&#9;&#9;&#9;payloadValues.computeIfAbsent(playerUuid) { resourceLocation to TreeObject() }&#10;&#9;&#9;&#9;&#9;&#9;&#9;.second[option.id] = configObject.serializer.toTree(value, option.valueType)&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;return payloadValues.map { (uuid, pair) -&gt; CommonConfigPayload(pair.first, pair.second, Optional.of(uuid)) }&#10;&#9;}&#10;&#10;&#9;/**&#10;&#9; * Applies the given values to the given config object.&#10;&#9; */&#10;&#9;fun ConfigObject&lt;*&gt;.applyConfigPayload(tree: TreeObject, playerUuid: UUID?) {&#10;&#9;&#9;println(tree)&#10;&#9;&#9;val options = requireNotNull(configs[resourceLocation]) { &quot;Config $resourceLocation is not registered&quot; }&#10;&#9;&#9;for (option in options) {&#10;&#9;&#9;&#9;val deserialized = serializer.fromTree(tree[option.id]!!, option.valueType)&#10;&#9;&#9;&#9;requireNotNull(deserialized) { &quot;Failed to deserialize value for option ${option.property.name}&quot; }&#10;&#9;&#9;&#9;if (playerUuid != null) // Set synced value for the player&#10;&#9;&#9;&#9;&#9;option.playerValues[playerUuid] = deserialized&#10;&#9;&#9;&#9;else // Set synced value for the server&#10;&#9;&#9;&#9;&#9;option.serverValue = deserialized&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;fun createJsonObject(resourceLocation: ResourceLocation): TreeObject {&#10;&#9;&#9;val options = requireNotNull(configs[resourceLocation]) { &quot;Config $resourceLocation is not registered&quot; }&#10;&#9;&#9;val tree = TreeObject()&#10;&#9;&#9;for (option in options) {&#10;&#9;&#9;&#9;val configObject = option.configObject&#10;&#9;&#9;&#9;tree[option.id] = configObject.serializer.toTree(option.initialValue, option.valueType)&#10;&#9;&#9;}&#10;&#9;&#9;return tree&#10;&#9;}&#10;&#10;&#9;class SyncableOption&lt;T : Any?&gt;(val configObject: ConfigObject&lt;*&gt;, val property: KProperty0&lt;T&gt;) {&#10;&#9;&#9;val id: String = &quot;${configObject.resourceLocation}#${property.javaClass.declaringClass?.name ?: property::class.qualifiedName}.${property.name}&quot;&#10;&#9;&#9;val valueType: KType = property.returnType&#10;&#9;&#9;val initialValue: T get() = property.get()&#10;&#10;&#9;&#9;internal val playerValues = mutableMapOf&lt;UUID, T&gt;()&#10;&#9;&#9;var serverValue: T? = null&#10;&#9;&#9;&#9;get() = field ?: initialValue&#10;&#10;&#9;&#9;operator fun get(player: UUID): T {&#10;&#9;&#9;&#9;val playerValue = playerValues[player]&#10;&#9;&#9;&#9;if (playerValue != null) return playerValue&#10;&#9;&#9;&#9;PandaLib.logger.warn(&quot;No synced value for player $player in config option ${property.name}&quot;)&#10;&#9;&#9;&#9;return initialValue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;operator fun get(player: Player): T = this[player.uuid]&#10;&#9;}&#10;}&#10;&#10;fun ConfigObject&lt;*&gt;.syncOption(property: KProperty0&lt;*&gt;) {&#10;&#9;configs.computeIfAbsent(this.resourceLocation) { mutableListOf() } +=&#10;&#9;&#9;ConfigSynchronizer.SyncableOption(this, property)&#10;}&#10;&#10;@Suppress(&quot;UNCHECKED_CAST&quot;)&#10;fun &lt;T : Any?&gt; ConfigObject&lt;*&gt;.getSynced(property: KProperty&lt;T&gt;): ConfigSynchronizer.SyncableOption&lt;T&gt; {&#10;&#9;return requireNotNull(configs[this.resourceLocation]?.find { it.property == property }) {&#10;&#9;&#9;&quot;Synced property $property is not registered for config ${this.resourceLocation}&quot;&#10;&#9;} as ConfigSynchronizer.SyncableOption&lt;T&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>